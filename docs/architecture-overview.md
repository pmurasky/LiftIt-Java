# LiftIt Backend – Architecture Overview

## Core Architecture

- Java 25
- Spring Boot
- Gradle
- Separate repository from frontend
- YAGNI principle
- TDD (Test-Driven Development)

---

## Infrastructure

- Docker (local development + CI)
- GitHub Actions for CI
- Testcontainers for integration tests
- PostgreSQL database

---

## Database Strategy

### Migration
- Liquibase
- YAML changelogs
- Liquibase runs automatically on application startup in all environments

### Naming Conventions
- snake_case
- lowercase only
- plural table names

### Primary Keys
- Every table has:
  - `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
  - Single-column primary key
- Sequences managed automatically by Postgres

### Audit Fields (Required on All Tables)
- `created_at TIMESTAMP WITH TIME ZONE`
- `created_by`
- `updated_at TIMESTAMP WITH TIME ZONE`
- `updated_by`

### Timestamp Standard
- All timestamps use `TIMESTAMP WITH TIME ZONE`
- Stored in UTC

### Deletion Strategy
- Hard deletes only
- Every deletion recorded in a separate deletion audit mechanism
- Deletion auditing applies to all tables

---

## Security & Identity

### Overview

- Authentication required for all endpoints
- Auth0 as external identity provider (Auth0 Hosted Universal Login)
- Spring Security configured as a JWT Resource Server (validates Auth0-issued tokens)
- Local `users` table for application profile data only — Auth0 owns credentials
- The backend **never issues, stores, or refreshes tokens** — Auth0 does

### Authentication Flow

```
1. Frontend redirects user to Auth0 Universal Login
2. User authenticates on Auth0 (not on LiftIt backend)
3. Auth0 redirects back to frontend with an authorization code
4. Frontend exchanges the code with Auth0 directly for:
      - access_token  (JWT, short-lived ~1 hour)
      - refresh_token (long-lived, for obtaining new access tokens)
      - id_token      (OIDC token with user profile claims)
5. Frontend includes the access_token on every API request:
      Authorization: Bearer <access_token>
6. LiftIt Java backend validates the JWT:
      - Verifies signature against Auth0's JWKS endpoint
      - Validates issuer (iss) and audience (aud) claims
      - Returns 401 Unauthorized if token is missing, invalid, or expired
7. On token expiry, frontend calls Auth0 directly with the refresh_token to obtain a new access_token
```

### What the Backend Does (and Does Not Do)

| Responsibility | Owner |
|---|---|
| Issuing access tokens | Auth0 |
| Issuing refresh tokens | Auth0 |
| Handling login UI | Auth0 Universal Login |
| Token refresh | Frontend ↔ Auth0 directly |
| Validating JWT on each request | LiftIt Java (Spring Security) |
| Storing user profile (name, email, etc.) | LiftIt Java (`users` table) |
| Storing credentials or passwords | Auth0 — never LiftIt |

### Token Contract

- **Transport**: `Authorization: Bearer <access_token>` HTTP header on every request
- **Format**: JWT (signed RS256 by Auth0)
- **Validation**: Spring Security verifies signature via Auth0 JWKS endpoint (`https://<tenant>.auth0.com/.well-known/jwks.json`)
- **Claims checked**: `iss` (issuer), `aud` (audience), `exp` (expiry)
- **No cookies, no server-side sessions** — fully stateless

### Frontend Integration

The frontend should use an Auth0 SDK appropriate for their stack:

| Stack | SDK |
|---|---|
| React / Next.js | `@auth0/auth0-react` or `@auth0/nextjs-auth0` |
| Vue | `@auth0/auth0-vue` |
| Angular | `@auth0/auth0-angular` |
| Vanilla JS / other | `@auth0/auth0-spa-js` |

These SDKs handle the full OAuth2 PKCE flow, token storage, silent refresh, and attaching the Bearer token to outgoing requests automatically.

### Security Rules

- All endpoints require a valid JWT unless explicitly marked public
- No endpoint issues, accepts, or stores passwords
- JWT validation happens in Spring Security filter chain — controllers never see unauthenticated requests
- Rate limiting applied to all auth-adjacent endpoints

---

## API Design

- REST (no GraphQL, no gRPC)
- OpenAPI contract maintained
- Versioned base path: `/api/v1/...`
- Plural resource names
- No verbs in URLs
- HTTP method conventions:
  - POST → Create
  - GET → Retrieve
  - PATCH → Partial update
  - DELETE → Hard delete
  - PUT avoided unless true full-replacement required
- Standard HTTP status codes (200, 201, 204, 400, 401, 403, 404)

---

## Engineering Philosophy

- YAGNI (avoid premature abstraction)
- TDD
- Simplicity over speculative scalability
- Industry-standard REST practices
- Schema discipline and consistency

