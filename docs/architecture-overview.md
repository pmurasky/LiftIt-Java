# LiftIt Backend – Architecture Overview

## Core Architecture

- Java 25
- Spring Boot
- Gradle
- Separate repository from frontend
- YAGNI principle
- TDD (Test-Driven Development)

---

## Infrastructure

- Docker (local development + CI)
- GitHub Actions for CI
- Testcontainers for integration tests
- PostgreSQL database

---

## Database Strategy

### Migration
- Liquibase
- SQL format changelogs (`.sql` files with `--liquibase formatted sql` header)
- Liquibase runs automatically on application startup in all environments

### Liquibase Rules (Non-Negotiable)

#### Never modify an applied changeset
Once a changeset has been applied, Liquibase stores its checksum in the `DATABASECHANGELOG`
table. If you modify the changeset SQL, Liquibase will detect the checksum mismatch and
**fail to start** in any environment where it previously ran. This is true even for whitespace
or comment changes.

**Rule: Applied changesets are immutable. Always write a new changeset to amend.**

#### Changeset granularity
One changeset = one logical unit of work. Do not split a single logical change into many
one-statement changesets, and do not bundle unrelated changes into one changeset.

**Examples:**
- ✅ One changeset to fix all columns on a single table (one logical correction)
- ✅ One changeset to create a new table (one logical addition)
- ❌ One changeset per `ALTER TABLE` statement (too granular — over-engineering)
- ❌ One changeset that creates three unrelated tables (too broad — hard to roll back)

#### Changelog file format
Use SQL format. Each file must begin with:
```sql
--liquibase formatted sql
```
Each changeset block begins with:
```sql
--changeset author:id
```
The `id` must be unique within the file. Convention: use a short descriptive slug
(e.g. `liftit:create-users-table`), not a bare integer.

#### Rollback
Every changeset should include a `--rollback` comment documenting the inverse operation.
For complex changes (e.g. column type changes with data), note that rollback may require
manual intervention.

#### File naming convention
```
V{version}__{description}.sql
```
- Version is an integer, incrementing from 1
- Description uses underscores, lowercase
- Double underscore separates version from description
- Examples: `V1__create_users_table.sql`, `V2__fix_users_table.sql`

### Naming Conventions
- snake_case
- lowercase only
- plural table names

### Primary Keys
- Every table has:
  - `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
  - Single-column primary key
- Sequences managed automatically by Postgres
- `users.id` sequence starts at `100` — IDs 1–99 reserved for system/seed accounts
- All other domain tables start at `1`

### System / Seed Accounts
- A system admin user (`id = 1`) is inserted as the first Liquibase changelog entry
  - `auth0_id = 'system'`, `email = 'system@liftit.internal'`
  - `created_by = 1`, `updated_by = 1` (self-referencing)
- IDs 2–99 are reserved for future system accounts
- All real user accounts start at `id = 100`
- This allows `created_by` and `updated_by` to be `NOT NULL` on **all** tables including `users`
  — the system admin user is always a valid reference on first insert

### Audit Fields (Required on All Tables)
- `created_at TIMESTAMP WITH TIME ZONE NOT NULL`
- `created_by BIGINT NOT NULL` — FK to `users.id`; use system admin (`id = 1`) for seed/system-generated rows
- `updated_at TIMESTAMP WITH TIME ZONE NOT NULL`
- `updated_by BIGINT NOT NULL` — FK to `users.id`; use system admin (`id = 1`) for seed/system-generated rows

### Timestamp Standard
- All timestamps use `TIMESTAMP WITH TIME ZONE`
- Stored in UTC

### Deletion Strategy
- Hard deletes only
- Every deletion recorded in a separate deletion audit mechanism
- Deletion auditing applies to all tables

---

## Domain Tables

### `users`
Stores application identity data only. Auth0 owns credentials — this table is never used for authentication, only for linking Auth0 identity to application data.

| Column | Type | Constraints | Notes |
|--------|------|-------------|-------|
| `id` | `BIGINT GENERATED BY DEFAULT AS IDENTITY` | PK | |
| `auth0_id` | `VARCHAR NOT NULL` | UNIQUE | Auth0 `sub` claim — stable, never changes even if email changes |
| `email` | `VARCHAR(255) NOT NULL` | UNIQUE | Synced from Auth0 on login |
| `created_at` | `TIMESTAMP WITH TIME ZONE NOT NULL` | | |
| `created_by` | `BIGINT NOT NULL` | FK → `users.id` | System admin (`id = 1`) on first insert |
| `updated_at` | `TIMESTAMP WITH TIME ZONE NOT NULL` | | |
| `updated_by` | `BIGINT NOT NULL` | FK → `users.id` | System admin (`id = 1`) on first insert |

**What this table does NOT store:**
- Passwords or credentials (Auth0 owns these — never stored here)
- Username or display name (deferred to `user_profiles` — see Future Tables)
- Any lifting/workout data

### `user_profiles`
Lifting-specific profile data. 1-to-1 with `users` via `user_id`. Created during onboarding when the user supplies a username.

| Column | Type | Constraints | Notes |
|--------|------|-------------|-------|
| `id` | `BIGINT GENERATED BY DEFAULT AS IDENTITY` | PK | |
| `user_id` | `BIGINT NOT NULL` | UNIQUE, FK → `users.id` | 1-to-1 relationship |
| `username` | `VARCHAR(30) NOT NULL` | UNIQUE | User-supplied at profile creation |
| `display_name` | `VARCHAR(100)` | | Optional |
| `gender` | `VARCHAR(20)` | | Optional. e.g. male, female, non_binary, prefer_not_to_say |
| `birthdate` | `DATE` | | Optional. For age-group PRs and Wilks/DOTS coefficient |
| `height_cm` | `DECIMAL(5,1)` | | Optional. Metric storage; UI converts to imperial if needed |
| `units_preference` | `VARCHAR(10) NOT NULL` | CHECK (metric, imperial) | Defaults to metric |
| `created_at` | `TIMESTAMP WITH TIME ZONE NOT NULL` | | |
| `created_by` | `BIGINT NOT NULL` | FK → `users.id` | |
| `updated_at` | `TIMESTAMP WITH TIME ZONE NOT NULL` | | |
| `updated_by` | `BIGINT NOT NULL` | FK → `users.id` | |

**What this table does NOT store:**
- Body weight (time-series weight lives in `body_weight_history`)

### Future Tables (not yet implemented)

#### `body_weight_history`
Time-series body weight entries per user. Enables relative strength tracking (e.g. Wilks/DOTS coefficient) and progress over time.
Depends on `user_profiles` being implemented first (issue #30).

---

## Security & Identity

### Overview

- Authentication required for all endpoints
- Auth0 as external identity provider (Auth0 Hosted Universal Login)
- Spring Security configured as a JWT Resource Server (validates Auth0-issued tokens)
- Local `users` table for application profile data only — Auth0 owns credentials
- The backend **never issues, stores, or refreshes tokens** — Auth0 does

### Authentication Flow

```
1. Frontend redirects user to Auth0 Universal Login
2. User authenticates on Auth0 (not on LiftIt backend)
3. Auth0 redirects back to frontend with an authorization code
4. Frontend exchanges the code with Auth0 directly for:
      - access_token  (JWT, short-lived ~1 hour)
      - refresh_token (long-lived, for obtaining new access tokens)
      - id_token      (OIDC token with user profile claims)
5. Frontend includes the access_token on every API request:
      Authorization: Bearer <access_token>
6. LiftIt Java backend validates the JWT:
      - Verifies signature against Auth0's JWKS endpoint
      - Validates issuer (iss) and audience (aud) claims
      - Returns 401 Unauthorized if token is missing, invalid, or expired
7. On token expiry, frontend calls Auth0 directly with the refresh_token to obtain a new access_token
```

### What the Backend Does (and Does Not Do)

| Responsibility | Owner |
|---|---|
| Issuing access tokens | Auth0 |
| Issuing refresh tokens | Auth0 |
| Handling login UI | Auth0 Universal Login |
| Token refresh | Frontend ↔ Auth0 directly |
| Validating JWT on each request | LiftIt Java (Spring Security) |
| Storing user profile (name, email, etc.) | LiftIt Java (`users` table) |
| Storing credentials or passwords | Auth0 — never LiftIt |

### Token Contract

- **Transport**: `Authorization: Bearer <access_token>` HTTP header on every request
- **Format**: JWT (signed RS256 by Auth0)
- **Validation**: Spring Security verifies signature via Auth0 JWKS endpoint (`https://<tenant>.auth0.com/.well-known/jwks.json`)
- **Claims checked**: `iss` (issuer), `aud` (audience), `exp` (expiry)
- **No cookies, no server-side sessions** — fully stateless

### Frontend Integration

The frontend should use an Auth0 SDK appropriate for their stack:

| Stack | SDK |
|---|---|
| React / Next.js | `@auth0/auth0-react` or `@auth0/nextjs-auth0` |
| Vue | `@auth0/auth0-vue` |
| Angular | `@auth0/auth0-angular` |
| Vanilla JS / other | `@auth0/auth0-spa-js` |

These SDKs handle the full OAuth2 PKCE flow, token storage, silent refresh, and attaching the Bearer token to outgoing requests automatically.

### Security Rules

- All endpoints require a valid JWT unless explicitly marked public
- No endpoint issues, accepts, or stores passwords
- JWT validation happens in Spring Security filter chain — controllers never see unauthenticated requests
- Rate limiting applied to all auth-adjacent endpoints

---

## API Design

- REST (no GraphQL, no gRPC)
- OpenAPI contract maintained
- Versioned base path: `/api/v1/...`
- Plural resource names
- No verbs in URLs
- HTTP method conventions:
  - POST → Create
  - GET → Retrieve
  - PATCH → Partial update
  - DELETE → Hard delete
  - PUT avoided unless true full-replacement required
- Standard HTTP status codes (200, 201, 204, 400, 401, 403, 404)

---

## Engineering Philosophy

- YAGNI (avoid premature abstraction)
- TDD
- Simplicity over speculative scalability
- Industry-standard REST practices
- Schema discipline and consistency

